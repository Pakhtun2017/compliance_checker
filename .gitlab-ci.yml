stages:
  - init-infra
  - build_push
  - deploy
  - cleanup    

variables:
  IMAGE_TAG: "latest"

terraform:
  stage: init-infra
  image: alpine:latest
  tags: [aws]
  variables:
    TF_IN_AUTOMATION: "1"
    TF_VAR_ecr_repo: "$ECR_REPO"     
    TF_VAR_state_bucket_name: "$STATE_BUCKET"
    TF_VAR_lock_table_name: "$LOCK_TABLE"
  before_script:
    - apk add --no-cache curl unzip bash git aws-cli
    - curl -sSLO https://releases.hashicorp.com/terraform/1.12.2/terraform_1.12.2_linux_amd64.zip
    - mkdir -p tfbin && unzip -o terraform_1.12.2_linux_amd64.zip -d tfbin
    - mv tfbin/terraform /usr/local/bin/terraform
    - terraform version
  script:
    # ── Bootstrap: init (local state)
    - terraform -chdir=terraform/bootstrap init -no-color -input=false

    # ── Import-if-exists (idempotent)
    - |
      # Import bucket if it already exists
      if aws s3api head-bucket --bucket "$STATE_BUCKET" 2>/dev/null; then
        echo "Bucket $STATE_BUCKET exists; importing into state..."
        terraform -chdir=terraform/bootstrap import -no-color aws_s3_bucket.tf_state "$STATE_BUCKET" || true
      else
        echo "Bucket $STATE_BUCKET not found; will be created by apply."
      fi

      # Import lock table if it already exists
      if aws dynamodb describe-table --table-name "$LOCK_TABLE" >/dev/null 2>&1; then
        echo "DynamoDB table $LOCK_TABLE exists; importing into state..."
        terraform -chdir=terraform/bootstrap import -no-color aws_dynamodb_table.tf_locks "$LOCK_TABLE" || true
      else
        echo "DynamoDB table $LOCK_TABLE not found; will be created by apply."
      fi

    # ── Apply bootstrap (create if missing, configure if present)
    - terraform -chdir=terraform/bootstrap apply -auto-approve -no-color

    # ── Init main with S3 backend (now that bucket/table exist)
    - terraform -chdir=terraform init -no-color -input=false -reconfigure -backend-config=backend.hcl

    # ── Apply main stack
    - terraform -chdir=terraform apply -auto-approve -no-color -lock-timeout=300s

    # ── Export outputs for later stages
    - echo "ECR_REPO_URL=$(terraform -chdir=terraform output -raw ecr_repo_url)" >> tf_outputs.env
    - echo "S3_BUCKET=$(terraform -chdir=terraform output -raw compliance_bucket_name)" >> tf_outputs.env
    - echo "EKS_ROLE_ARN=$(terraform -chdir=terraform output -raw flask_dashboard_irsa_role_arn)" >> tf_outputs.env
    - echo "EKS_CLUSTER_NAME=$(terraform -chdir=terraform output -raw eks_cluster_name)" >> tf_outputs.env
  artifacts:
    when: always         # ensure cleanup can still grab files if we fail
    reports:
      dotenv: tf_outputs.env
    paths:
      - terraform/**
    expire_in: 2 days

build_and_push:
  stage: build_push
  needs: ["terraform"]                 # pulls tf_outputs.env => ECR_REPO_URL available
  image: python:3.11
  services: [docker:dind]
  variables:
    DOCKER_HOST: tcp://docker:2375/
    DOCKER_TLS_CERTDIR: ""
    IMAGE_TAG: "latest"
  tags: [aws]
  script:
    - apt update && apt install -y curl unzip docker.io
    - curl -sSLO https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip
    - unzip -q awscli-exe-linux-x86_64.zip
    - ./aws/install
    - aws --version

    # Build tag using the TF-managed repo URI
    - IMAGE_URI="${ECR_REPO_URL}:${IMAGE_TAG}"
    - echo "Using ECR_REPO (name)    = $ECR_REPO"
    - echo "Using ECR_REPO_URL (URI) = $ECR_REPO_URL"
    - echo "Using IMAGE_URI          = $IMAGE_URI"

    - aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REPO_URL"
    - docker build -t "$IMAGE_URI" .
    - docker push "$IMAGE_URI"

deploy:
  stage: deploy
  image:
    name: amazon/aws-cli:2.15.29
    entrypoint: [""]           # important with aws-cli image
  tags: [aws]
  needs: ["terraform", "build_and_push"]
  before_script:
    - aws --version
    - yum -y install openssl tar gzip 
    - curl -sSL -o kubectl "https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl && mv kubectl /usr/local/bin/kubectl
    - curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    - aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"
    - kubectl get nodes
  script:
    - >
      helm upgrade --install compliance-dashboard ./compliance-dashboard
      --namespace compliance --create-namespace
      -f compliance-dashboard/values.yaml
      --set image.repository="$ECR_REPO_URL"
      --set-string image.tag="$IMAGE_TAG"
      --set env.S3_BUCKET="$S3_BUCKET"
      --set env.DASHBOARD_PASSWORD="$DASHBOARD_PASSWORD"
      --set env.FLASK_SECRET_KEY="$FLASK_SECRET_KEY"
      --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"="$EKS_ROLE_ARN"

cleanup_on_failure:
  stage: cleanup
  image: alpine:latest
  tags: [aws]
  when: on_failure
  needs: ["terraform"]            # pulls terraform/** artifact
  variables:
    TF_IN_AUTOMATION: "1"
    GIT_STRATEGY: none            # skip repo fetch entirely
    TF_VAR_ecr_repo: "$ECR_REPO"
    TF_VAR_state_bucket_name: "$STATE_BUCKET"
    TF_VAR_lock_table_name: "$LOCK_TABLE"
    TF_VAR_aws_region: "$AWS_REGION"
  before_script:
    - apk add --no-cache curl unzip bash git aws-cli openssl tar gzip
    - curl -sSLO https://releases.hashicorp.com/terraform/1.12.2/terraform_1.12.2_linux_amd64.zip
    - mkdir -p tfbin && unzip -o terraform_1.12.2_linux_amd64.zip -d tfbin
    - mv -f tfbin/terraform /usr/local/bin/terraform
    - terraform version
    # kubectl & helm for uninstall
    - curl -sSL -o kubectl "https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl && mv kubectl /usr/local/bin/kubectl
    - curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
  script:
    # Fallback: if artifact missing, fetch repo with CI_JOB_TOKEN
    - |
      if [ ! -d terraform ]; then
        echo "terraform/ not found; fetching repo fallback..."
        git init .
        git remote add origin "$CI_REPOSITORY_URL"
        git -c http.extraHeader="Authorization: Bearer $CI_JOB_TOKEN" fetch --depth 1 origin "$CI_COMMIT_SHA"
        git checkout -qf FETCH_HEAD
      fi

    # 1) Helm uninstall (tears down ELB/ENIs) with wait-loop
    - |
      set +e
      aws eks update-kubeconfig --region "$AWS_REGION" --name "${EKS_CLUSTER_NAME:-eks-cluster}" || true
      helm uninstall compliance-dashboard -n compliance || true
      for i in $(seq 1 30); do
        kubectl get svc -n compliance compliance-dashboard >/dev/null 2>&1 || break
        echo "Waiting for Service deletion... ($i/30)"; sleep 10
      done
      set -e

    # 2) Empty ECR repo (avoids RepositoryNotEmpty)
    - |
      set +e
      if [ -n "$ECR_REPO_URL" ]; then
        aws ecr batch-delete-image \
          --repository-name "${ECR_REPO_URL##*/}" \
          --image-ids "$(aws ecr list-images --repository-name "${ECR_REPO_URL##*/}" --query 'imageIds' --output json)" \
          --region "$AWS_REGION" || true
      fi
      set -e

    # 3) Two-phase Terraform destroy
    - terraform -chdir=terraform init -input=false -reconfigure -backend-config=backend.hcl -no-color
    - terraform -chdir=terraform destroy -auto-approve -lock-timeout=300s -no-color -target=module.eks || true
    - terraform -chdir=terraform destroy -auto-approve -lock-timeout=300s -no-color || true

destroy_manual:
  stage: cleanup
  image: alpine:latest
  tags: [aws]
  when: manual
  allow_failure: false
  needs: ["terraform"]            # pulls same artifact
  variables:
    TF_IN_AUTOMATION: "1"
    GIT_STRATEGY: none
    TF_VAR_ecr_repo: "$ECR_REPO"
    TF_VAR_state_bucket_name: "$STATE_BUCKET"
    TF_VAR_lock_table_name: "$LOCK_TABLE"
    TF_VAR_aws_region: "$AWS_REGION"
  environment:
    name: production
    action: stop
  before_script:
    - apk add --no-cache curl unzip bash git aws-cli openssl tar gzip
    - curl -sSLO https://releases.hashicorp.com/terraform/1.12.2/terraform_1.12.2_linux_amd64.zip
    - mkdir -p tfbin && unzip -o terraform_1.12.2_linux_amd64.zip -d tfbin
    - mv -f tfbin/terraform /usr/local/bin/terraform
    - terraform version
    - curl -sSL -o kubectl "https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl && mv kubectl /usr/local/bin/kubectl
    - curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
  script:
    - |
      if [ ! -d terraform ]; then
        echo "terraform/ not found; fetching repo fallback..."
        git init .
        git remote add origin "$CI_REPOSITORY_URL"
        git -c http.extraHeader="Authorization: Bearer $CI_JOB_TOKEN" fetch --depth 1 origin "$CI_COMMIT_SHA"
        git checkout -qf FETCH_HEAD
      fi
    # Helm uninstall + wait
    - |
      set +e
      aws eks update-kubeconfig --region "$AWS_REGION" --name "${EKS_CLUSTER_NAME:-eks-cluster}" || true
      helm uninstall compliance-dashboard -n compliance || true
      for i in $(seq 1 30); do
        kubectl get svc -n compliance compliance-dashboard >/dev/null 2>&1 || break
        echo "Waiting for Service deletion... ($i/30)"; sleep 10
      done
      set -e
    # Empty ECR (safety)
    - |
      set +e
      if [ -n "$ECR_REPO_URL" ]; then
        aws ecr batch-delete-image \
          --repository-name "${ECR_REPO_URL##*/}" \
          --image-ids "$(aws ecr list-images --repository-name "${ECR_REPO_URL##*/}" --query 'imageIds' --output json)" \
          --region "$AWS_REGION" || true
      fi
      set -e
    # Two-phase destroy
    - terraform -chdir=terraform init -input=false -reconfigure -backend-config=backend.hcl -no-color
    - terraform -chdir=terraform destroy -auto-approve -lock-timeout=300s -no-color -target=module.eks
    - terraform -chdir=terraform destroy -auto-approve -lock-timeout=300s -no-color
# Trigger pipeline
# Trigger pipeline
# Trigger pipeline
# Trigger pipeline
